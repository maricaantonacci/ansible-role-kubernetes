---
- name: Create a directory if it does not exist
  file:
    path: /etc/kubernetes/pki
    state: directory
    mode: '0755'

- name: Create auth data file with an admin user
  copy:
    content: '{{kube_admin_token}},{{kube_admin_username}},100,"users,system:masters"'
    dest: /etc/kubernetes/pki/auth
    mode: 600

- name: Kubeadm init
  command: kubeadm init --pod-network-cidr={{kube_pod_network_cidr}} --token={{kube_token}} --token-ttl {{kube_token_ttl}} --apiserver-advertise-address={{kube_api_server}} creates=/etc/kubernetes/admin.conf

- name: wait Kube to start
  wait_for:
    host: "{{ kube_api_server }}"
    port: 6443

- name: install flannel
  block:
  - lineinfile:
      dest: /etc/sysctl.d/k8s.conf
      regexp: '^net.bridge.bridge-nf-call-iptables'
      line: 'net.bridge.bridge-nf-call-iptables = 1'
      create: yes
    notify: sysctl-system
  - template:
      src: templates/flannel.yaml
      dest: /etc/kube-flannel.yml
  - command: kubectl apply -f /etc/kube-flannel.yml creates=/etc/cni/net.d/10-flannel.conflist
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
  when: network_manager == "flannel"

- name: install calico
  block:
  - get_url:
      url: https://docs.projectcalico.org/manifests/custom-resources.yaml
      dest: /etc/kube-calico-crds.yml
  - get_url:
      url: https://docs.projectcalico.org/manifests/tigera-operator.yaml 
      dest: /etc/kube-calico-operator.yml
  - command: "{{item}}"
    with_items:
      - 'kubectl apply -f /etc/kube-calico-operator.yml'
      - 'kubectl apply -f /etc/kube-calico-crds.yml'
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
  when: network_manager == "calico"

- include: helm.yaml
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  when: kube_install_helm

- name: Add Kube API server options
  lineinfile:
    dest: /etc/kubernetes/manifests/kube-apiserver.yaml
    line: '    - {{item.option}}={{item.value}}'
    regexp: '^    - {{item.option}}='
    insertafter: '    - kube-apiserver'
  notify: restart kubeapi
  with_items: "{{ kube_apiserver_options }}"

- name: wait Kube to start
  wait_for:
    host: "{{ kube_api_server }}"
    port: 6443

- name: Set iptables for ingress floatingIPs
  block:
    - command: 'iptables -F'     
    - name: 'iptables -A FORWARD -p tcp -d {{nginx_ingress.master_private_ip }} --dport 443,80 -j ACCEPT'
      iptables:
        chain: FORWARD
        protocol: tcp
        destination: "{{ nginx_ingress.master_private_ip }}"
        destination_port: "{{ item }}"
        jump: ACCEPT
        comment: "managed by kubernetes ansible role"
      loop:
        - 443
        - 80        
    - name: 'iptables -t nat -A PREROUTING -p tcp -d {{nginx_ingress.master_public_ip }} --dport 443,80 -j DNAT --to-destination {{nginx_ingress.master_private_ip }}:443,80'
      iptables:
        table: nat
        chain: PREROUTING
        protocol: tcp
        destination: "{{ nginx_ingress.master_public_ip }}"
        destination_port: "{{ item }}"
        jump: DNAT
        to_destination: "{{ nginx_ingress.master_private_ip }}:{{ item }}"
        comment: "managed by kubernetes ansible role"
      loop:
        - 443
        - 80              
    - name: 'iptables -t nat -A POSTROUTING ! -s 127.0.0.1 -j MASQUERADE'
      iptables:
        table: nat     
        chain: POSTROUTING
        source: '! 127.0.0.1'
        jump: MASQUERADE
        comment: "managed by kubernetes ansible role"
    - command: 'iptables-save'
      

- name: wait Kube to start
  wait_for:
    host: "{{ kube_api_server }}"
    port: 6443

- name: install nginx ingress
  block:
    - copy:
        src: files/nginx-namespace.yaml
        dest: /etc/nginx-namespace.yml
    - template:
        src: templates/nginx-values.yaml
        dest: /etc/nginx-ingress-values.yml
    - command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
      - helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
      - helm repo update
      - kubectl apply -f  /etc/nginx-namespace.yml
      - "helm upgrade --install --cleanup-on-fail --wait --timeout 30m0s \
                              ingress-nginx \
                              ingress-nginx/ingress-nginx \
                              --set controller.allowSnippetAnnotations=false \
                              --namespace=ingress-nginx \
                              --version {{ nginx_ingress_helm_version }} \
                              --values /etc/nginx-ingress-values.yml"
  when: nginx_ingress.enabled

- name: install cert manager
  block:
    - copy:
        src: files/cert-manager-namespace.yaml
        dest: /etc/cert-manager-namespace.yml
    - command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
          - helm repo add jetstack https://charts.jetstack.io
          - helm repo update
          - kubectl apply -f /etc/cert-manager-namespace.yml
          - "helm upgrade --install --cleanup-on-fail --wait --timeout 30m0s \
                      cert-manager jetstack/cert-manager \
                      --namespace cert-manager \
                      --version {{ cert_manager_helm_version }} \
                      --set installCRDs=true"
  when: nginx_ingress.enabled

- name: wait Cert-Manager to start
  command: kubectl get deployment -n cert-manager -l 'app=webhook' -o 'jsonpath={.items[0].status.readyReplicas}'
  register: cert_manager_webhook_deployment_status
  until: (cert_manager_webhook_deployment_status.stdout | default(0) | int) >= 1
  retries: 30
  delay: 15
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf

  when: nginx_ingress.enabled


- name: define cluster issuer
  block:
    - template:
        src: cluster-certs.yaml
        dest: /etc/cluster-certs.yml 
    - command: "kubectl apply -f /etc/cluster-certs.yml"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf

- name: install dashboard
  block:
    - copy:
        src: files/metric-server.yaml
        dest: /etc/metric-server.yml
    - template:
        src: templates/dashboard-values.yaml
        dest: /etc/dashboard-values.yml
    - command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
      - helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/
      - helm repo update
      - kubectl apply -f /etc/metric-server.yml
      - "helm upgrade --install --cleanup-on-fail --wait --timeout 30m0s \
                             dashboard kubernetes-dashboard/kubernetes-dashboard \
                             --namespace=kube-system \
                             --version {{ dashboard_helm_version }} \
                             --values /etc/dashboard-values.yml"
  when: nginx_ingress.enabled

- name: install prometheus
  block:
    - copy:
        src: files/prometheus-namespace.yaml
        dest: /etc/prometheus-namespace.yml
    - template:
        src: templates/prometheus-values.yaml
        dest: /etc/prometheus-values.yml
    - command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
      - helm repo add prometheus https://prometheus-community.github.io/helm-charts
      - helm repo update
      - kubectl apply -f /etc/prometheus-namespace.yml
      - "helm upgrade --install --cleanup-on-fail --wait --timeout 30m0s \
                             prometheus prometheus/prometheus \
                             --namespace=prometheus \
                             --version {{ prometheus_helm_version }} \
                             --values /etc/prometheus-values.yml"
  when: nginx_ingress.enabled

- name: install kube-eagle 
  block:
    - copy:
        src: files/eagle-namespace.yaml
        dest: /etc/eagle-namespace.yml
    - command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
      - helm repo add kube-eagle https://raw.githubusercontent.com/cloudworkz/kube-eagle-helm-chart/master
      - helm repo update
      - kubectl apply -f /etc/eagle-namespace.yml
      - "helm upgrade --install --cleanup-on-fail --wait --timeout 30m0s \
                             kube-eagle kube-eagle/kube-eagle \
                             --version {{ kube_eagle_helm_version }} \
                             --namespace=kube-eagle"
  when: nginx_ingress.enabled

- name: install grafana 
  block:
    - template:
        src: templates/grafana-secret.yaml
        dest: /etc/grafana-secret.yml
    - copy:
        src: files/grafana-namespace.yaml
        dest: /etc/grafana-namespace.yml
    - template:
        src: templates/grafana-values.yaml
        dest: /etc/grafana-values.yml
    - command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
      - helm repo add grafana https://grafana.github.io/helm-charts
      - helm repo update
      - kubectl apply -f /etc/grafana-namespace.yml
      - kubectl apply -n grafana -f /etc/grafana-secret.yml
      - "helm upgrade --install --cleanup-on-fail --wait --timeout 30m0s \
                             grafana grafana/grafana \
                             --namespace=grafana \
                             --version {{ grafana_helm_version }}
                             --values /etc/grafana-values.yml"
  when: nginx_ingress.enabled

- name: copy empty kubeconfig
  copy:
    src: files/kubeconfig
    dest: /etc/kubeconfig
  
#- name: expose apiserver trhough ingress
#  block:
#    - template:
#        src: templates/api-server-ingress.yaml
#        dest: /etc/api-server-ingress.yaml
#    - command: "{{ item }}"
#      environment:
#        KUBECONFIG: /etc/kubernetes/admin.conf
#      with_items:
#      - kubectl apply -f /etc/api-server-ingress.yaml

- name: create service account for remote access
  shell: |
    kubectl -n kube-system create --dry-run=client serviceaccount admin -o yaml | kubectl apply -f - \
    && kubectl create --dry-run=client clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:admin -o yaml | kubectl apply -f - \
    && sleep 30 \
    && export TOKENNAME=`kubectl -n kube-system get serviceaccount/admin -o jsonpath='{.secrets[0].name}'` \
    && export TOKEN=`kubectl -n kube-system get secret $TOKENNAME -o jsonpath='{.data.token}' | base64 -d` \
    &&  kubectl config --kubeconfig=/etc/kubeconfig set-credentials admin --token=$TOKEN \
    && kubectl config --kubeconfig=/etc/kubeconfig set-cluster public --server=https://{{nginx_ingress.dns_name }}:6443 --insecure-skip-tls-verify \
    && kubectl config --kubeconfig=/etc/kubeconfig set-context public --cluster=public --namespace=default --user=admin \
    && kubectl config --kubeconfig=/etc/kubeconfig use-context public
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf

- name: register kubeconfig
  shell: kubectl config  --kubeconfig=/etc/kubeconfig view --raw
  register: kubeconfig
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf

- name: KUBECONFIG file
  debug:
    var: kubeconfig.stdout.split('\n')
